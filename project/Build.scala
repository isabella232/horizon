/**
 * Copyright 2013-2014 PayPal
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import com.typesafe.sbt.SbtSite.SiteKeys._
import java.io.PrintWriter
import org.eclipse.jgit.storage.file.FileRepositoryBuilder
import sbt._
import Keys._
import sbtunidoc.Plugin._
import com.typesafe.sbt.pgp.PgpKeys._
import com.typesafe.sbt.SbtSite._
import com.typesafe.sbt.SbtGit._
import GitKeys._
import com.typesafe.sbt.SbtGhPages._
import GhPagesKeys._
import sbtrelease._
import sbtrelease.Utilities._
import scala.io.Source
import net.virtualvoid.sbt.graph.Plugin
import org.scalastyle.sbt.ScalastylePlugin
import org.scalastyle.sbt.ScalastylePlugin._
import de.johoop.jacoco4sbt._
import JacocoPlugin._
import ReleaseStateTransformations._
import ReleasePlugin._
import ReleaseKeys._

object BuildUtilitiesKeys {
  lazy val ghpagesDir = SettingKey[String]("build-utilities-ghpages-directory", "unique folder structure for the git project gh-pages branch")
  lazy val readmeTemplateMappings = SettingKey[Map[String, String]]("build-utilities-readme-template-mappings", "Mappings for generating readme file")
}

object BuildSettings {
  import AdditionalReleaseSteps._
  import BuildUtilitiesKeys._

  val org = "com.paypal"
  val scalaVsn = "2.10.4"
  val nexusHost = "https://oss.sonatype.org"
  private val gitDir = new File(".", ".git")
  private val repo = FileRepositoryBuilder.create(gitDir)
  private val originUrl = repo.getConfig.getString("remote", "origin", "url")
  private def extractDirStructure(str: String): String = {
    val gitRemoved = str.replace(".git", "")
    val colonsReplaced = gitRemoved.replace(":", "/")
    val splitStr = colonsReplaced.split('/')
    val repo = splitStr(splitStr.length - 1)
    val name = splitStr(splitStr.length - 2)
    s"$name/$repo"
  }

  lazy val standardPluginSettings = Defaults.coreDefaultSettings ++
    releaseSettings ++
    Plugin.graphSettings ++
    ScalastylePlugin.projectSettings ++
    jacoco.settings ++
    site.settings ++
    ghpages.settings ++
    unidocSettings ++
    Seq(
      ghpagesNoJekyll := false,
      ghpagesDir := extractDirStructure(originUrl),
      repository <<= ghpagesDir.apply (dir => file(System.getProperty("user.home")) / ".sbt" / "ghpages" / dir),
      siteMappings <++= (mappings in (ScalaUnidoc, packageDoc), version).map { (mapping, ver) =>
        for((file, path) <- mapping) yield (file, s"api/$ver/$path")
      },
      synchLocal <<= (privateMappings, updatedRepository, gitRunner, streams).map { (mappings, repo, git, s) =>
        val betterMappings = mappings.map { case (file, t) => (file, repo / t) }
        IO.copy(betterMappings)
        repo
      },
      git.remoteRepo := originUrl,
      tagName <<= (version in ThisBuild).map(a => a),
      readmeTemplateMappings <<= (version in ThisBuild) { ver =>
        Map("version" -> ver)
      },
      readmeTemplateMappings ++= Map("auto-gen" -> "THIS FILE WAS AUTO GENERATED BY THE README TEMPLATE. DO NOT EDIT DIRECTLY."),
      releaseProcess := Seq[ReleaseStep](
        checkSnapshotDependencies,
        inquireVersions,
        ensureChangelogEntry,
        runTest,
        setReleaseVersion,
        commitReleaseVersion,
        generateReadme,
        tagRelease,
        publishArtifacts.copy(action = publishSignedAction),
        generateAndPushDocs,
        setNextVersion,
        commitNextVersion,
        pushChanges
      )
    )

  lazy val standardSettings = standardPluginSettings ++ Seq(
    organization := org,
    name := "horizon",
    scalaVersion := scalaVsn,
    sbtPlugin := true,
    conflictManager := ConflictManager.strict,
    fork := true,
    scalacOptions ++= Seq("-deprecation", "-unchecked", "-feature", "-Xlint", "-target:jvm-1.7"),
    scalacOptions in Test ++= Seq("-Yrangepos"),
    dependencyOverrides <++= scalaVersion { vsn => Set(
      "org.scala-lang" % "scala-library"  % vsn,
      "org.scala-lang" % "scala-compiler" % vsn
    )},
    addSbtPlugin("com.github.gseitz" % "sbt-release" % "0.8.5"),
    addSbtPlugin("com.typesafe.sbt" % "sbt-ghpages" % "0.5.2" exclude("com.typesafe.sbt", "sbt-git")),
    addSbtPlugin("com.typesafe.sbt" % "sbt-site" % "0.7.0"),
    addSbtPlugin("com.typesafe.sbt" % "sbt-git" % "0.6.4" exclude ("org.eclipse.jgit", "org.eclipse.jgit")),
    addSbtPlugin("com.jsuereth" % "sbt-pgp" % "1.0.0"),
    addSbtPlugin("com.eed3si9n" % "sbt-unidoc" % "0.3.0"),
    libraryDependencies ++= Seq(
      "org.eclipse.jgit" % "org.eclipse.jgit" % "3.3.0.201403021825-r",
      "org.specs2" %% "specs2" % "2.4.15" % "test"
    ),
    apiURL := Some(url("http://paypal.github.io/horizon/api/")),
    autoAPIMappings := true,
    publishTo := {
      val nexus = s"$nexusHost/"
        if (isSnapshot.value) {
            Some("snapshots" at nexus + "content/repositories/snapshots")
        } else {
            Some("releases"  at nexus + "service/local/staging/deploy/maven2")
        }
    },
    // scalaz-stream_2.10 is not on Maven Central, until that changes, this line needs to stay in
    resolvers += Resolver.bintrayRepo("scalaz", "releases"),
    scalastyleConfigUrl in Compile := Option(url("https://raw.githubusercontent.com/paypal/scala-style-guide/develop/scalastyle-config.xml")),
    publishMavenStyle := true,
    publishArtifact in Test := false,
    pomIncludeRepository := { _ => false },
    pomExtra :=
      <url>https://github.com/paypal/horizon</url>
      <licenses>
        <license>
          <name>Apache 2</name>
          <url>http://www.apache.org/licenses/LICENSE-2.0.txt</url>
          <distribution>repo</distribution>
        </license>
      </licenses>
      <scm>
        <url>git@github.com:paypal/horizon.git</url>
        <connection>scm:git:git@github.com:paypal/horizon.git</connection>
      </scm>
      <developers>
        <developer>
          <id>msv</id>
          <name>Matt Vaznaian</name>
          <url>https://github.com/msv</url>
        </developer>
        <developer>
          <id>arschles</id>
          <name>Aaron Schlesinger</name>
          <url>https://github.com/arschles</url>
        </developer>
        <developer>
          <id>taylorleese</id>
          <name>Taylor Leese</name>
          <url>https://github.com/taylorleese</url>
        </developer>
      </developers>
  )
}

object UtilitiesBuild extends Build {
  import BuildSettings._

  lazy val root = Project(id = "root", base = file("."), settings = standardSettings)

}

/**
 * Adds step to ensure an entry for the current release version is present in the changelog,
 * generate and push ScalaDocs to gh-pages branch, and generate readme with release version injected.
 */
object AdditionalReleaseSteps {
  import BuildUtilitiesKeys._

  lazy val ensureChangelogEntry: ReleaseStep = { st: State =>
    try {
      checkChangelog(st)
      st
    } catch {
      case entry: ChangelogEntryMissingException => sys.error(entry.getMessage)
    }
  }

  val changelog = "CHANGELOG.md"

  class ChangelogEntryMissingException(e: Throwable) extends Exception(e)

  private def getReleasedVersion(st: State): String = st.get(versions).getOrElse(sys.error("No versions are set! Was this release part executed before inquireVersions?"))._1

  private def checkChangelog(st: State) {
    try {
      val currentChangelog = Source.fromFile(changelog).mkString
      val version = getReleasedVersion(st)
      if (!currentChangelog.contains(version)) {
        throw new Exception(s"No changelog entry found for current release version $version.")
      }
    } catch {
      case e: Throwable => throw new ChangelogEntryMissingException(e)
    }
  }

  lazy val publishSignedAction: State => State = { st: State =>
    val extracted = st.extract
    val ref = extracted.get(thisProjectRef)
    extracted.runAggregated(publishSigned in Global in ref, st)
  }

  lazy val generateAndPushDocs: ReleaseStep = { st: State =>
    val st2 = executeTask(makeSite, "Making doc site")(st)
    executeTask(pushSite, "Publishing doc site")(st2)
  }

  private def executeTask(task: TaskKey[_], info: String) = (st: State) => {
    st.log.info(info)
    val extracted = st.extract
    val ref: ProjectRef = extracted.get(thisProjectRef)
    val (newState, _) = extracted.runTask(task in ref, st)
    newState
  }

  val readme = "README.md"
  val readmeTemplate = "Readme-Template.md"

  lazy val generateReadme: ReleaseStep = { st: State =>
    val version = getReleasedVersion(st)
    generateReadmeFromMappings(st, version)
    commitReadme(st, version)
    st
  }

  private def generateReadmeFromMappings(st: State, newVersion: String): Unit = {
    val extracted = st.extract
    val templateMappings = extracted.get(readmeTemplateMappings)
    val template = Source.fromFile(readmeTemplate).mkString
    val out = new PrintWriter(readme, "UTF-8")
    try {
      val newReadme = templateMappings.foldLeft(template) { (currentReadme, mapping) =>
        val (regKey, replacement) = mapping
        val regex = s"\\{\\{$regKey\\}\\}".r
        regex.replaceAllIn(currentReadme, replacement)
      }
      newReadme.foreach(out.write(_))
    } finally {
      out.close()
    }
  }

  private def commitReadme(st: State, newVersion: String): Unit = {
    val vcs = st.extract.get(versionControlSystem).getOrElse(sys.error("Unable to get version control system."))
    vcs.add(readme) !! st.log
    vcs.commit(s"README.md updated to $newVersion") ! st.log
  }

}
